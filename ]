pub mod redis;
use api_db::{Db, Model, Id};
use crate::util::respond;
use api_common::models::Session;
use actix_web::{
    Responder, HttpRequest, HttpResponse, guard,
    web::{self, Json, Data, Path, ServiceConfig}
};

pub fn routes(cfg: &mut ServiceConfig) {
    cfg
        .service(web::scope("/id/{id}").configure(routes_id))
        .service(web::scope("/userid/{user_id}").configure(routes_user_id))
        .service(web::scope("/redis").configure(redis::routes));
}

pub fn routes_id(cfg: &mut ServiceConfig) {
    cfg
        .service(web::scope("/{id}")
            .service(web::resource("")
                .route(web::get().to(get_by_id))
                .route(web::post().to(add_by_id))
                .route(web::put().to(update_by_id))
                .route(web::delete().to(delete_by_id))
            )
            .service(web::resource("/status")
                .route(web::get().to(get_status_by_id))
                .route(web::post().to(update_status_by_id))
            )
        );
}
pub fn routes_user_id(cfg: &mut ServiceConfig) {
    cfg
        .service(web::resource("")
            .route(web::get().to(get_by_user_id))
            .route(web::post().to(add_by_user_id))
            .route(web::put().to(update_by_user_id))
            .route(web::delete().to(delete_by_user_id))
        )
        .service(web::resource("/status")
            .route(web::get().to(get_status_by_user_id))
            .route(web::post().to(update_status_by_user_id))
        );
}
pub async fn get_all(req: HttpRequest, db: Data<Db>) -> impl Responder {
    match Session::get_all(&db.pool).await {
        Ok(sess) => respond::ok(sess),
        Err(e) => respond::err(e)
    }
}

pub async fn get_by_id(db: Data<Db>, user_id: Path<Id>) -> impl Responder {
    match Session::get(&db.pool, user_id.into_inner()).await {
        Ok(sess) => respond::ok(sess),
        Err(e) => respond::err(e)
    }
}
pub async fn get_by_user_id(db: Data<Db>, user_id: Path<Id>) -> impl Responder {
    match Session::get(&db.pool, user_id.into_inner()).await {
        Ok(sess) => respond::ok(sess),
        Err(e) => respond::err(e)
    }
}

pub async fn delete_by_user_id(db: Data<Db>, user_id: Path<Id>) -> impl Responder {
    match Session::delete(&db.pool, user_id.into_inner()).await {
        Ok(sess) => respond::ok(sess),
        Err(e) => respond::err(e)
    }
}

/// TODO fix this
pub async fn add_by_id(db: Data<Db>, user_id: Path<Id>) -> impl Responder {
    let id: Id = user_id.into_inner();
    match Session::create_two_day_session(&db.pool, id).await {
        Ok(sess) => respond::ok(sess),
        Err(e) => respond::err(e)
    }
}
pub async fn add_by_user_id(db: Data<Db>, user_id: Path<Id>) -> impl Responder {
    match Session::create_two_day_session(&db.pool, user_id.into_inner()).await {
        Ok(sess) => respond::ok(sess),
        Err(err) => respond::err(err),
    }
}
pub async fn update_by_user_id(db: Data<Db>, user_id: Path<Id>) -> impl Responder {
    format!("PUT /user/session/user/{}", &user_id)
}
pub async fn update_status_by_user_id(db: Data<Db>, user_id: Path<Id>) -> impl Responder {
    format!("PUT /user/session/user/status/{}", &user_id)
}
pub async fn update_status_by_id(db: Data<Db>, user_id: Path<Id>) -> impl Responder {
    format!("PUT /user/session/{}/status", &user_id)
}
pub async fn get_status_by_id(db: Data<Db>, id: Path<Id>) -> impl Responder {
    match Session::get(&db.pool, id.into_inner()).await {
        Ok(Some(sess)) => respond::ok(sess),
        Ok(None) => respond::not_found("None with that ID"),
        Err(e) => respond::err(e)
    }
}
pub async fn get_status_by_user_id(db: Data<Db>, user_id: Path<Id>) -> anyhow::Result<impl Responder> {
    Ok(format!("GET /user/session/{}/status", &user_id))
}
pub async fn delete_by_id(db: Data<Db>, id: Path<Id>) -> impl Responder {
    match Session::delete(&db.pool, id.into_inner()).await {
        Ok(sess) => respond::ok(sess),
        Err(e) => respond::err(e)
    }
}
pub async fn update_by_id(db: Data<Db>, user_id: Path<Id>) -> impl Responder {
    format!("PUT /user/session/{}", &user_id)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::test::*;
    use actix_web::{test::{self, TestRequest}, web, };

    #[actix_rt::test]
    async fn insert_two_non_unique_emails_fails() -> anyhow::Result<()> {
        Ok(())
    }

    #[actix_rt::test]
    async fn test_index_get_all_users() -> anyhow::Result<()> {
        let db = db().await?;
        let u1 = add_user(&db, "user1", "user1@email.com");
        let u2 = add_user(&db, "user2", "user2@email.com");
        let u3 = add_user(&db, "user3", "user3@email.com");
        let srv = service("/user", web::get().to(get_all)).await;
        let req = TestRequest::get().uri("/user")
            .to_http_request();
        let resp = get_all(req, Data::new(db)).await;
        assert!(resp.status().is_ok());
        Ok(())
    }

    #[actix_rt::test]
    async fn create_session_ok() -> anyhow::Result<()> {
        let user = add_user("user1", "user1@email.com").await;
        let session = Session::create(user.id, Expiration::two_days())
            .await.unwrap();
        user.add_record
        let sess = Session {

        }
        let srv = test::init_service(App::new()
            .data(db.await)
            .route("/user/session", web::post().to(add_new))
        ).await;
        let req = TestRequest::post().uri("/user/session")
            .set_json(data)

    }
}
